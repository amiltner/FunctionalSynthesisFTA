type nat =
  | O
  | S of nat

type list =
  | Nil
  | Cons of nat * list

type cmp =
  | LT
  | EQ
  | GT

let compare =
  fix (compare : nat -> nat -> cmp) =
    fun (x1 : nat) ->
      fun (x2 : nat) ->
        match (x1,x2) with
        | (O,O) -> EQ
        | (O,S _) -> LT
        | (S _,O) -> GT
        | (S x1,S x2) -> compare x1 x2
;;

synth list -> list satisfying

type bool =
  | True
  | False

let for_all =
  fix (for_all : (nat -> bool) -> list -> bool) =
    fun (f:nat -> bool) -> (fun (l:list) ->
      match l with
      | Nil -> True
      | Cons (h,t) -> (match f h with
              | False -> False
              | True -> for_all f t))
;;

let contains =
  fix (contains : list -> nat -> bool) =
    fun (l:list) -> (fun (n:nat) ->
      match l with
      | Nil -> False
      | Cons (h,t) -> (match compare h n with
              | LT -> contains t n
              | GT -> contains t n
              | EQ -> True))
;;

let and =
  fun (b1:bool) ->
    fun (b2:bool) ->
      match b1 with
      | True -> b2
      | False -> False
;;

let no_dupes =
  fix (no_dupes : list -> bool) =
    fun (l:list) ->
      (match l with
         | Nil -> True
         | Cons (h,Nil) -> True
         | Cons (h1,Cons(h2,t)) -> (match compare h1 h2 with
                     | EQ -> False
                     | LT -> no_dupes (Cons(h2,t))
                     | GT -> no_dupes (Cons(h2,t))))
;;

fun (inp:list) ->
  (fun (out:list) ->
    (and
      (for_all (contains out) inp)
      (no_dupes out)))